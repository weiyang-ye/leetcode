<!--
 * @Author: error: git config user.name && git config user.email & please set dead value or install git
 * @Date: 2022-08-27 19:11:30
 * @LastEditors: error: git config user.name && git config user.email & please set dead value or install git
 * @LastEditTime: 2022-08-30 15:43:30
 * @FilePath: \Leetcode\数组.md
 * @Description: 这是默认设置,请设置`customMade`, 打开koroFileHeader查看配置 进行设置: https://github.com/OBKoro1/koro1FileHeader/wiki/%E9%85%8D%E7%BD%AE
-->
# 数组

## 数组理论基础

- 数组是**存放在连续内存的相同类型数据的集合**
- 数组可以方便地通过下标索引的方式来获取下标对应的数据，**数据下标都是从0开始的**
- 在删除或者增添元素的时候，就难免要移动其他元素的地址
![删除或增添元素](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)
- **C++中，二维数组在内存中的空间地址是连续的**
![C++中的二维数组](https://img-blog.csdnimg.cn/20210310150641186.png)
- Java中，由于寻址操作直接交给了虚拟机，所以看不到每个元素的地址情况，可能的排列方式如下：
![Java中的二维数组](https://img-blog.csdnimg.cn/20201214111631844.png)

## 二分查找

- 题目：给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。
- **时间复杂度计算：**假设一个数组长度为n,每次查找后数据长度减半，第一次查找后数据长度为n/2,第二次查找后数据长度为n/(2的2次方)，第k次查找后数据长度为n/(2的k次方)，最坏情况下**数据长度为1时找到该数，即n/(2的k次方)=1, 解得k=log2(N)**
- **二分查找的思想：**（升序数列）比较一个元素与数列中的中间位置的元素的大小，如果比中间位置的元素大，则继续在后半部分的数列中进行二分查找；如果比中间位置的元素小，则在数列的前半部分进行比较；如果相等，则找到了元素的位置。
- 二分查找的应用范围：
    1. 数组为有序数组
    2. 数组中无重复元素
- 关键点
    1. 在书写边界条件的时候要注意**循环不变量**规则：在while寻找中每一次边界的处理都要坚持根据区间的定义来操作
    2. 数组的起始点在0
    3. 中值计算时候需要防止溢出：
    int middle = left + ((right - left) / 2)
- 两种书写方式
    1. target $\in$ [left,right]：
        - while(**left<=right**)
        - if (nums[middle] > target) right 要赋值为 middle - 1，因为当前这个nums[middle]一定不是target，那么接下来要查找的左区间结束下标位置就是 middle - 1
        - 一开始数组的右边界为num.size-1
        ![左闭右闭](https://img-blog.csdnimg.cn/20210311153055723.jpg)
    2. target $\in$ [left,right):
        - while (**left < right**)
        - if (nums[middle] > target) right 更新为 middle
        - 一开始数组右边界为num.size
        ![左闭右开](https://img-blog.csdnimg.cn/20210311153123632.jpg)

## 移除元素

- 题目：给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。不要使用额外的数组空间，你必须**仅使用 O(1) 额外空间**并**原地**修改输入数组。元素的顺序可以改变。**你不需要考虑数组中超出新长度后面的元素。**
- 解法
    1. 暴力解法：双层for循环，第一层循环遍历数组元素，第二层循环更新数组
        - 时间复杂度为O($n^2$)
        - 空间复杂度为O(1)
        ![暴力解法](https://tva1.sinaimg.cn/large/008eGmZEly1gntrc7x9tjg30du09m1ky.gif)
    2. 双指针解法： 通过一个快指针和慢指针在一个for循环下完成两个for循环的工作。
        - 快指针：寻找新数组的元素 ，新数组就是不含有目标元素的数组
        - 慢指针：指向更新后新数组下标的位置
        - 时间复杂度：O($n$)
        - 空间复杂度：O(1)
        ![双指针解法](https://tva1.sinaimg.cn/large/008eGmZEly1gntrds6r59g30du09mnpd.gif)

## 有序数组的平方

- 题目：给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。
- 解法：
    1. 暴力解法：每个数平方之后进行排序
        - Java中排序需导入`import java.util.Arrays;`，使用`Array.sort(result)`函数。
        - 算法的时间复杂度为$O(n+nlogn)=O(nlogn)$
    2. 双指针法： 
        - 这种数组是有序的，数组的平方最大值可能在数组两端，这样的话我们采用双指针，第一个指针放在左边，第二个指针放在右边。
        - 结果数组的指针从终止位置开始（即优先更新最大值）
        - 时间复杂度为$O(n)$
        ![双指针法图示](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

## 长度最小的子数组

- 题目：给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。
- 解法：
    1. 暴力法：两层for循环不停迭代寻找符合的子序列
        - 时间复杂度为$O(n^2)$
    2. 滑动窗口法：不断的调节子序列的起始位置和终止位置，从而得出我们要想的结果。
    ![滑动窗口示意图](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)
        - 窗口是什么？
            - 满足其和 ≥ s 的长度最小的 连续 子数组
        - 如何移动窗口的起始位置？**关键**
            - 如果当前窗口的值大于s了，窗口就要向前移动了（也就是该缩小了）
            ![精髓](https://img-blog.csdnimg.cn/20210312160441942.png)
        - 如何移动窗口的结束位置？
            - 窗口的结束位置就是遍历数组的指针，也就是for循环里的索引。

## 螺旋矩阵

- 题目：给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。
- 解法：**坚持循环不变量！**
    - 模拟顺时针画矩阵的过程：填充上行从左到右，填充右列从上到下，填充下行从右到左，填充左列从下到上
    - 要一直坚持**左闭右开**的原则！！
    - 每个圈循环的次数：`int loop=n/2`
    - 每个循环的起始位置需要定义：第二圈开始的时候，起始位置要各自加1， 例如：第一圈起始位置是(0, 0)，第二圈起始位置是(1, 1)
    - 需要控制每一条边遍历的长度，每次循环右边界收缩一位
    - 如果n为奇数`n%2!=0`的话，需要单独给矩阵最中间`n>>2`的位置赋值
